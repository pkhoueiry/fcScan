---
title: "fcScan"
author:
- Pierre Khoueiry
- Ghiwa Khalil
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
package: fcScan
vignette: >
  %\VignetteEngine{knitr::rmarkdown}  
  %\VignetteIndexEntry{fcScan}  
  %\VignetteEncoding{UTF-8}
---

```{r, setup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```


## Table of Contents
* [Introduction](#introduction) 
* [Dependencies](#Dependencies)  
* [Install Packages](#Install Packages) 
* [Overview](#Overview)
    + [Input arguments for getCluster](#Input arguments for getCluster)
    + [Output of getCluster](#Output of getCluster)
* [Example on Clustering](#Example on Clustering)  
* [Parallelism](#Parallelism)  
* [Session Info](#Session Info)


## <a id="introduction"></a> Introduction

Biological information encoded in the DNA sequene is often organized into
independent modules or clusters. For instance, the eukaryotic system of
expression relies on combinations of homotypic or heterotypic transcription
factors (TFs) which play an important role in activating and repressing
target genes.

In disease state, genomics regions with increased mutational hotspots are
associated with disease initiation and progression.

fcScan is a package designed to detect clusters of genomic features based on 
user defined search criteria. Such criteria include:  
    
* A list of BED/VCF files or a dataframe of input data
* The required window size of the clusters to identify
* The combination of features required from input files or dataframe
* The order of features required within identified clusters
* The distance required between each cluster   
* On which strand to build the clusters   
* On which chromosome to build the clusters   


## <a id="Dependencies"></a> Dependencies

fcScan requires the following packages to be installed for the 
usage of getCluster :

* **parallel**
* **doParallel**
* **foreach**
* **stats**
* **utils**
* **VariantAnnotation**
* **rtracklayer**
* **matrixStats**
* **GenomicRanges**
* **tools**

## <a id="Overview"></a> Overview

fcScan finds clusters of genomic features based on user defined 
parameters. Currently, it has one main function, the `getCluster`
function.


## <a id="Input arguments for getCluster"></a> Input arguments for getCluster


>`clusters = getCluster(x=c("NANOG.bed","TATA.bed"), w = 1500, c = c("NANOG"=1,"TATA"=2), greedy = TRUE, overlap = -5, s = "+", chr = "chr9",order = c("TATA","NANOG","NANOG"))`


### Input data (x)
The input for `getCluster` is given through the parameter `x`.
This function takes BED and VCF files (compressed or not). BED-12, BED-6, BED-4,
and Bed-3 file formats are valid.
There is no limit on the number of files the user can define.

Alternatively, `getCluster` accepts a data frame as input. In this case,
this data frame should have 5 columns containing the following.

* **chr** : Contains the chromosome name
* **start**: Contains start coordinates
* **end**: Contains end coordinates
* **strand**: Contains strand relative to each site
* **site** : Contains the family name relative to genomic site

```{r, echo=FALSE, results='asis'}
df <- data.frame(chr = c("chr1", "chr1", "chr1", "chr1", "chr1", "chr1"),
                 start = c(10, 17, 25, 27, 32, 41), 
                 end=c(15, 20, 30, 35, 40, 48),
                 strand = c("+", "+", "+", "+", "+", "+"),
                 site = c("1", "2", "2", "1", "3", "2"))

knitr::kable(df)
```

The *chr*, *start* and *end* columns are the relative position of each
feature/site.
The *site* column contains the ID of the site and will be used for clustering.
*start* and *end* columns are numeric while the rest are characters.

### Window Size (w)
Window size is set using `w`, and this parameter defines the maximum size of the
clusters.

### Condition (c)
The clustering condition `c` defines the number and type of genomic data to 
search for in each cluster based on the information in the `site` column
`c = c("TATA" = 1, "GATA" = 2)`  
This searches for clusters with 3 sites, One *TATA* and two  *GATA*.

Another way of writing the condition is the following 
`x = ("TATA.bed","GATA.bed"), c = c(1,2)`  
Given 2 files, *TATA.bed* and *GATA.bed*, this condition states that the user is 
looking for clusters made from 1 TATA site and 2 GATA sites. In this case, the\
order of sites defined in `c` is relative to the order of files.

In case the input is a data frame (instead of files), the user needs to **explicitly** 
define the site name along with the count relative to each site. 
Giving the condition as `c = c(1,2)` for a data frame will not be allowed.  
`x = dataFrame_of_sites, c = c("TATA" = 1, "GATA" = 2)` where `TATA`
 and `GATA` are site names in the `site` column.
 
### Chromosome (chr) and Strand (s)
By default, the clusters will be built on both strands and all chromosomes
unless specified by the user using the `chr` and `s` arguments to limit the
search on a specific chromosome or strand.

Users can choose to cluster on one specific chromosome `(chr = "chr1")`, or
on more than one chromosome `(chr = c("chr1","chr3","chr4"))`  
(Default of `chr` is **NULL**) meaning that clustering on all chromosomes 
will be performed.

For `s`, the values allowed are: 

* **+** : Build clusters on positive strand
* **-** : Build clusters on negative strand
* **.** : Clusters are not strand specific  
(Default of `s` is **.**)

### Overlap (overlap)
The gap/overlap between adjacent clusters can be controled using the `overlap`
option.
When `overlap` is positive, adjacent clusters will be separated by a minimum
of the given value.
When `overlap` is negative, adjacent clusers will be allowed to overlap by a maximum
of the given value.  
(Default is **0**)

### Greedy vs Non-Greedy (greedy)
`greedy` allows the user to control the number of genomic features found 
in clusters.

When `greedy = FALSE`, `getCluster` will build clusters having the required
window size and will label *TRUE* the ones that contain the **exact** number
and type of sites provided in the condition argument.
Clusters having the user defined window size but not satisfying
the condition will be labelled as *FALSE*.

When `greedy = TRUE`, additional sites will be added to the cluster as
long as the cluster size is below the difined  window size.
(Default is **TRUE**)  


### Order (order)
The `order` option allows the user to define the specific order for the
combination of sites required.  
Given the order in the above example to be :
`order = c("TATA","NANOG","NANOG")`
This will search for a cluster containing the above sites in the exact same order.
They can be a sub order of a larger cluster or simply a cluster containing these sites.
For example if a cluster has "TATA TATA NANOG NANOG NANOG", this cluster has the required
order and therefore will be conisdered as a correct cluster.
(Default is **NULL**)

### Number of cores (n_cores)
This parameter allows the user to control the number of cores used by 
`getCluster` when using parallel.  
(Default is **2**)

## <a id="Output of getCluster"></a> Output of getCluster

The output of `getCluster` is a Genomic Range object with fields containing:

* **chr**: The chromosome on which a cluster is found
* **start**: The start of the cluster
* **end**: The end of the cluster
* **size**: The size of the cluster
* **sites**: The combination of sites that define the cluster
* **strand**: The strand of the cluster, if any
* **isCluster**: A logical indicating if the cluster is TRUE or FALSE
* **status**: Describes the reason behind the rejection of a cluster 
* **score**: A score of 1 is added to all the clusters to have the elements of
a bed format. Currently this score is insignificant.

The algorithm returns all clusters containing the correct count of
sites/features. If the combination, overlap, and order options are satisfied,
the cluster is considered a `TRUE` cluster. 

*status* of a cluster might be either PASS, combnFail, or orderFail.
`PASS` is a cluster that satisfied the order and combination. `combnFail` is
a cluster that didn't satisfy the combination requirement and `orderFail` is a cluster
that had the required combination but did not have the required order of sites.

NOTE: If the user is using `greedy = FALSE` and `order` contains values more
than  in the condition parameter (`c`),  an error will be raised.
However, if `greedy = TRUE`, then using `order` with more values than the 
condition paramerter is allowed since a greedy cluster may contain more 
sites than the required `c` condition as long as the window size is respected.


## <a id = "Example on Clustering"></a> Example on Clustering

Following will be an example of how to use `getCluster` function.

The data can be downloaded from the following link [http://compbio.mit.edu/encode-motifs/]

*matches.txt* contains all known and discovered motifs for
the ENCODE TFChIP-seq datasets.

In this example, `getCluster` was performed on the NANOG_known1 motif
and TATA_known2 motif.

*matches.txt* is a large file so it would be more efficient to handle
it from the terminal using bash or any other alternative to extract the
required sites.


To get the sites for each motif:   
> `grep -i "NANOG_known1" matches.txt > "NANOG_known1.txt"`  
> `grep -i "TATA_known2" matches.txt > "TATA_known2.txt"`

### Clustering using a data frame as input

Read each file into R

> `NANOG = read.table("Path/To/File/NANOG_known1.txt", stringsAsFactors = FALSE)`  
> `TATA = read.table("Path/To/File/TATA_known2.txt", stringsAsFactors = FALSE)`

Rearrange the columns to have the required data frame

> `TATA = TATA[,c("V2","V3","V4","V5","V1")]`  
> `NANOG = NANOG[,c("V2","V3","V4","V5","V1")]`  
> `head(TATA)`

```{r, echo=FALSE, results='asis'}
df <- data.frame(chr =  c("chr1", "chr1", "chr1", "chr1", "chr1", 
                            "chr1"), 
                 start = c(25705L, 65916L, 119982L, 167008L, 266303L, 343330L), 
                 end = c(25719L, 65930L, 119996L, 167022L, 266317L, 343344L), 
                 strand = c("+", "-", "-", "+", "-", "+"),
                 site = c("TATA_known2", "TATA_known2", "TATA_known2", 
                          "TATA_known2", "TATA_known2", 
                          "TATA_known2"))

knitr::kable(df)
```

>`head(NANOG)`

```{r, echo=FALSE, results='asis'}
df <- data.frame(chr = c("chr1", "chr1", "chr1", "chr1", "chr1", "chr1"), 
                 start = c(89192L, 93669L, 235753L, 239997L, 363873L, 415307L), 
                 end = c(89203L, 93680L, 235764L, 240008L, 363884L, 415318L), 
                 strand = c("+", "+", "+", "+", "-", "-"), 
                 site = c("NANOG_known1", "NANOG_known1", "NANOG_known1", 
                          "NANOG_known1", "NANOG_known1", "NANOG_known1"))

knitr::kable(df)
```

>`x = rbind(TATA,NANOG)`  
>`colnames(x) = c("chr","start","end","strand","site")`



In the example below `getCluster` will search for clusters that contain a
minimum of 1 NANOG_known1 site and 2 TATA_known2 sites, found within 1000bp
(since greedy is set to TRUE by default),
and adjacent clusters should be seperated by a maximum of 5 overlapping base
pairs.
Since `chr` has the value `chr9` and `s` has the value `+`, clusters will
only be built on chromosome 9 only and for sites defined on the positive strand
exclusively.

>`clusters = getCluster(x , w = 20000 , c = c("NANOG_known1" = 1, "TATA_known2" = 2 ), overlap = -5, chr = "chr9", s = "+",order = c("TATA_known2","NANOG_known1","NANOG_known1"))`

The results are stored in a data frame named clusters. *clusters* contains 
1644 observations with 10 variables


>`head(clusters)`


```{r, echo=FALSE, results='asis'}
df <- data.frame(seqnames = c("chr9", "chr9", "chr9", "chr9", "chr9", "chr9","chr9"), 
                 start = c(25819, 165839, 202790, 253854, 361626, 
                           387689,5831142), 
                 end = c(25832, 165852, 202800, 253867, 361639,
                         387701,5846962), 
                 size = c("14", "14", "11", "14", "14", "14","15821"), 
                 site = c("TATA_known2", "TATA_known2", "NANOG_known1", 
                          "TATA_known2", "TATA_known2", "TATA_known2","TATA_known2,TATA_known2,NANOG_known1"), 
                 strand = c("+", "+", "+", "+", "+", "+","+"), 
                 isCluster = c("FALSE", "FALSE", "FALSE", "FALSE", "FALSE",
                               "FALSE","FALSE"),
                 id = c("c1", "c2", "c3", "c4", "c5", "c6","c94"),
                    score = c(1, 1, 1, 1, 1, 1,1))

knitr::kable(df)
```

The resulting GRanges object will contain the *TRUE* and *FALSE* labelled 
clusters as well as the reason why the clustering (status column) failed.
To get only the cluster labelled by *TRUE* We can subset by the following:
    
> `clusters_TRUE = subset(clusters, isCluster)`  
> `head(clusters_TRUE)`


```{r, echo=FALSE, results='asis'}
df <- data.frame(chr = c("chr9"), 
                 start = c(83497977), 
                 end = c(83517867), 
                 size = c(19891), 
                 site = c("TATA_known2,TATA_known2,TATA_known2,NANOG_known1,NANOG_known1"), 
                 strand = c("+"),
                isCluster = c("TRUE"), 
                 id = c("c882"),
                 score = c("1"))

knitr::kable(df)
```

*clusters_TRUE* contains 1 observation.

### Clustering using a data frame as input
Alternatively, we can call getCluster by using as input preformatted bed
files. Assuming NANOG and TATA sites are stored in bed files "nanog.bed" and
"tata.bed" respectively, the call for getCluster will be:

`clusters = getCluster(c("nanog.bed", "tata.bed") , w = 20000 , c = c("NANOG_known1" = 1, "TATA_known2" = 2 ), overlap = -5, chr = "chr9", s = "+")`

In this case, the "name column" in the bed file is ignoned and is replaced by 
the name given in the "c" argument.


## <a id="Parallelism"></a> Parallelism

This package uses parallelism by chromosome. One core will be allocated 
per chromosome. The number of cores is set to 2 by default.



## <a id="Session Info"></a> Session Info


```{r} 
sessionInfo() 
``` 
